---
title: "PRAC2: Tipologia i cicle de vida de les dades"
author: "Mila Ramírez Guevara"
date: "13/12/2020"
output:
  pdf_document: default
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

# 1. Descripción de los datos. 

Para este proyecto contamos con los datos de los pasajeros del Titanic. 
El estudio que queremos realizar es un pequeño proyecto de Machine Learning, para intentar predecir la supervivencia de los pasajeros en base a determinadas características de los mismos que tenemos registradas en el dataset. 

La importancia que tiene el proyecto es que nos permite responder a la pregunta en base a factores que tengamos de "nuevos" pasajeros. Es decir, en base a ciertos parametros habría sobrevivido el pasajero X. Supongamos que el pasajero x es un hombre, con un pasaje de segunda clase, sin hijos y 45 años de edad, ¿qué probabilidad tiene de sobrevivir a este accidente?

Y extrapolando este tipo de estudios a otras situaciones, un modelo similar nos podría permitir determinar si en función de ciertas características por ejemplo 
un usuario de una plataforma compraría determinado producto.
O un paciente con determinadas patologías o características respondería bien a x tratamiento.

También se debe tener en cuenta las siguientes notas sobre los datos que utilizaremos y el significado de las columnas que recogen las características de cada pasajero. 

<CENTER> ![](C:/Users/mila_/Documents/Master ciencia de dades/Tipología y ciclo de vida de los datos/PRAC 2/descripción datos.png){width='400'} </CENTER>


* pclass: A proxy for socio-economic status (SES)
  1st = Upper
  2nd = Middle
  3rd = Lower

* age: Age is fractional if less than 1. If the age is estimated, is it in the form of xx.5

* sibsp: The dataset defines family relations in this way...
  Sibling = brother, sister, stepbrother, stepsister
  Spouse = husband, wife (mistresses and fiancés were ignored)

* parch: The dataset defines family relations in this way...
  Parent = mother, father
  Child = daughter, son, stepdaughter, stepson
  Some children travelled only with a nanny, therefore parch=0 for them.

Así pues, contamos con 891 registros de 12 variables para el set de entrenamiento y 418 registros de 11 variables para el set de test. El total de registros será de 1309 y más adelante los veremos en detalle.

# 2. Integración y selección de los datos de interés a analizar

Lo primer que hago para determinar los datos de interés y la integración es revisar los datos de los que estoy partiendo. 

En mi caso tengo tres tipos de datos Train,test,gender_submision. En la descripción de los archivos que se puede encontrar en la fuente de Kaggle se indica que los datos se han dividido en datos de entrenamiento y de test para el modelo de machine learning que queremos crear 

* Train: csv con información sobre los pasajeros del Titanic para entrenar el modelo. Para este set de datos se proporciona el resultado final para cada pasajero indicando si este sobrevive o no. Y se espera que el modelo esté basado en las características de cada pasajero.
* Test: csv con información de los pasajeros a modo de test para probar el modelo. Este set de datos se debe usar para ver que tan bien funciona nuestro modelo con datos a ciegas de los que no conocemos el resultado en cuanto a si un pasajero sobrevive o no.
* gender_submission (es el resultado del modelo en caso de que se plantee que solo las mujeres sobreviven al accidente. y se proporciona como modelo del resultado que debemos obtener después de usar el modelo)

En base a la descripción de estos archivos es claro que los que debo usar para trabajar son el train y el test.

Para crear el modelo debo usar los datos del archivo train.csv, pero para testear el modelo tendré que usar los datos del archivo test.csv. Así que el primer paso será hacer una lectura de ambos archivos y verificar los datos con los que cuento.

```{r chunk 0}
#librerias necesarias

library(dplyr)
library(tidyverse)
library(ggplot2)
library(tidyverse)
library(hrbrthemes)
library(viridis)

#Cargar datos y primera revisión

Titanic_train<- read.csv(
  paste("C:/Users/mila_/Documents/Master ciencia de dades",
  "/Tipología y ciclo de vida de los datos/PRAC 2/train.csv",sep=""),
  header=TRUE)

Titanic_test<- read.csv(
  paste("C:/Users/mila_/Documents/Master ciencia de dades",
  "/Tipología y ciclo de vida de los datos/PRAC 2/test.csv",sep = ""),
  header=TRUE)


str(Titanic_train)


str(Titanic_test)
```

De esta primera revisión podemos ver que los datos con los que contamos en ambos archivos son similares para verificar que en efecto podemos usar train.csv como set de entrenamiento compararé las columnas con las que contamos en ambos dataframe, lo esperable es que train.csv  tenga un campo referido a la supervivencia y test.csv no cuente con el. ya lo hemos visto con la función str, pero dado que para combinar ambos archivos debemos verificar que los nombres de las variables son identicos he considerado oportuno revisar solo el nombre de las columnas, para ver si hay diferencias en la escritura(Mayúsculas, minúsculas,errores tipograficos...)

```{r chunk 1}
#Revisión de columnas en dataframes
colnames(Titanic_train)
colnames(Titanic_test)
```

De la revisión de columnas en efecto vemos que el archivo train.csv cuenta con una columna referida a la supervivencia. 

En este caso la integración de datos no sería obligatoria ya que para hacer el modelo puedo trabajar con los datos que me proporciona el archivo train csv, pero deberé hacer la limpieza de ambos datasets y dado que cuentan con prácticamente las mismas variables he considerado mejor hacer la limpieza en conjunto de todos los datos. 

Por lo tanto tendré que integrar los datos de train con test, y combinar ambos dataframes y más adelante volver a separarlos.

La variable survived, que solo está presente en el grupo de entrenamiento se debe añadir también al grupo tesT, por lo que creo una variable en el dataframe test que se llame "Survived" y tenga valores NA. Quiero además comprobar antes de combinar los dataframes que en el dataframe "train" no hay valores NA para Survived, y en efecto es así. 

Además para más adelante separar los datos tendré la opción de separar por el PassangerID, teniendo en cuenta de que se trata  de números consecutivos y podría hacer el corte en la fila 891 para el set de entrenamiento, u otra  opción sería usar el campo "Survived", pero la finalidad última del proyecto es que estos valores dejen de ser NA, y se puedan predecir, por lo que no sería un buen separador, así que he decidido añadir una nueva columna en ambos dataset para identificar si son registros de entrenamiento o test. 

```{r chunk 2}
paste("Los valores NA para variable Survived rn train son:",sum(is.na(Titanic_train$Survived)))

#nueva columna en test dataframe

Titanic_test$Survived <- NA

#nueva columna Set_type para separar dataframes más adelante
Titanic_test$Set_type<- "test"
Titanic_train$Set_type<- "train"

#combinación de datasets

Titanic_complete<- rbind(Titanic_train, Titanic_test)

#compruebo las filas del nuevo dataframe para ver si es correcto.
paste("Número de filas de Dataframe Titanic_complete:",nrow(Titanic_complete))
```

# 3. Limpieza de datos.

Antes de empezar la limpieza de datos propiamente dicha, quiero revisar la cantidad de datos de que dispongo, de manera más formal ya que esta información si está facilmente accesible en el apartado "global enviroment" de RStudio, pero para la presentación del trabajo considero que es importante tenerla visible. Así que haré un estudio muy preeliminar para determinar las dimensiones del dataframe con el que estoy trabajando y algunas características de las variables.  

```{r chunk 3}

#preliminar analysis of dataframe variables and dimensions

str(Titanic_complete)

```

Aquí comprobamos que el tipo de objeto es en efecto un Dataframe que contiene 1309 observaciones y 13 variables, los nombres de cada variable y la interpretación que hace R de cada una de ellas.

En la interpretación que hace R por defecto, se considera:

* variables numéricas discretas (int) : PassengerId, Survived, Pclass, Age, SibSp, Parch
* variables numéricas continuas (num):Fare
* variables tipo texto: Name, Sex, Ticket, Cabin, Embarked, set_type

De la interpretación de datos que ha hecho R podemos detectar que hay algunas diferencias con lo que podríamos interpretar nosotros.
Ya que las variables numéricas que interpreto serían (Age, SibSp,Parch y Fare)
Mientras que las variables Survived, Pclass,Sex,Cabin, Embarked y set_type deberían considerarse variables categóricas. 

PassagerID, que sirve para identificar a los pasajeros la mantendré como variable numérica, y la variable Name tal y como está planteada tampoco es representativa pero podemos hacer alguna transformación con ella y plantearla como un factor.

Interpretado esto lo que haré será cambiar la interpretación de variables que ha hecho R y establecer las variables categóricas que he considerado.


```{r chunk 4}
#change character to factor object

Titanic_complete$Survived<-as.factor(Titanic_complete$Survived)
Titanic_complete$Pclass<-as.factor(Titanic_complete$Pclass)
Titanic_complete$Sex<-as.factor(Titanic_complete$Sex)
Titanic_complete$Cabin<-as.factor(Titanic_complete$Cabin)
Titanic_complete$Embarked<-as.factor(Titanic_complete$Embarked)
Titanic_complete$Ticket<-as.factor(Titanic_complete$Ticket)
Titanic_complete$Set_type<-as.factor(Titanic_complete$Set_type)
#Titanic_complete$Name<-as.factor(Titanic_complete$Name)
```

## 3.1 Gestión de Zeros y elementos vacíos. 

Para iniciar esta sección, utilizo la función summary para tener un resumen y visión general de las variables categóricas, numéricas y también para poder detectar el número de missing values.

```{r chunk 5}
#summary of variables
summary(Titanic_complete)

#hecha la comprobación la única variable en la que es extraño encontrar valores 0 es en Fare ya que esto implica una tarifa gratuita, lo cual es extraño contabilizo el número de 0 para esta variable con el siguiente comando.

paste("número de registros con valor zero en la tarifa:",sum(Titanic_train$Fare==0))

```
Con esta primera conversión ya podemos detectar que hay valores missing en la variable Age se reflejan como NA al igual que en Fare, por otro lado en Cabin y embarked se reflejan como una variable vacía (null). Además hay valores zero en SibSp, Parch y Fare. No es extraño que haya valores zero en SibSp, Parch pero sí en Fare como se ha comentado. 

Los valores missing más relevantes los tenemos en Cabin y en Age por lo que habrá que tratarlos, Los otros valores missing corresponden a Embarked y Fare, pero en total son solo 3 registros por lo que se imputen o se eliminen  no deberían tener una gran repercusión.

De la función Summary también deduzco que las variables categoricas están normalizadas. Es decir, no hay variables que estén por ejemplo escritas en diferentes formas(Mayúsculas, minúsculas) y que representen la misma categoría sino que las nomenclaturas son homogéneas, donde podría sospechar que podría existir este problema sería en las variables Ticket y Cabin ya que como vemos contienen varios valores que se clasifican como "otros". Para poder acabar de comprobar esto he usado la función Table para hacer un conteo de los registros de cada variable

Pero de esta comprobación extraigo muy poca información ya que como es esperable hay una gran cantidad de tickets y de cabinas, me hace pensar que si quiero usar estas variables para el modelo tendré que tratarlas de alguna manera.

```{r chunk 6}

#comprobación de variables categóricas Cabin y TIcket
id.ticket_Cabin<-c(9,11)

var_ticket_Cabin<-colnames(Titanic_complete)[id.ticket_Cabin]

for (i in var_ticket_Cabin){
  
  print(tail(as.data.frame(table(Titanic_complete[i]),header=i)))
  
}

```

Por el momento he decidido considerar que las cabinas y tickets estan normalizados. Así que el siguiente paso es tratar los valores perdidos. 

### missing values en variable Embarked

Antes de optar por un método de imputación de variable he decidido revisar los pasajeros concretos que tienen estos valores perdidos para verificar si hay algo que nos pudiera dar una pista clara del puerto de Embarque, sabiendo que la mayoría de pasajeros embarcaron en el puerto S(South Hampton)una opción sería también asumir que para estos pasajeros el emarque fue en el puerto S.

```{r chunk 7}

Titanic_complete[Titanic_complete$Embarked=="",]

```

En esta primera vista, me llama la atención que las pasajeras coinciden en número ticket, tarifa, clase y cabina, así que es posible que embarcaran en el mismo puerto.No consta que viajaran con esposos,hermanos o hijos, por lo que descarto poder obtener el puerto de embarque  a partir de datos de posibles familiares que viajaran con ellas.

Si encuentro pasajeros que tengan la misma cabina o el mismo ticket es muy posible que embarcaran en el mismo puerto que estas dos pasajeras así que aplico el filtro correspondiente para detectar si hay otros pasajeros en la misma cabina o que tengan el mismo ticket 

```{r chunk 8}

#Busqueda de otros pasajeros con misma cabina o número de ticket.
Titanic.embarked<-Titanic_complete[Titanic_complete$PassengerId!=62 & Titanic_complete$PassengerId!=830,]
Titanic.embarked[Titanic.embarked$Cabin=="B28",]
Titanic.embarked[Titanic.embarked$Ticket==113572,]

#valorar usar knn???
#library(VIM)
#selected.vars<-c("Embarked","Pclass","Fare")
#output <- kNN( Titanic_complete[,selected.vars], variable=c("Embarked"), k=3 )
#output[output$BPD_imp==TRUE,]
```

No tengo ningún resultado, y a priori en este punto considero que al tratarse de únicamente 2 registros podríamos eliminarlos, y en un caso real seguramente los eliminaría, pero al tratarse de un proyecto para estudio y para una competición de Kaggle decido optar por buscar algún método de imputación. 

Una opción es encontrar los puertos de embarque considerando las clases y las tarifas. 

Utilizo la función table para verificar en que puertos han subido mayoritariamente los pasajeros de primera clase, ya que si hay una clara mayoría en este punto se resolvería el problema.

```{r chunk 9}
#Puertos de embarque segun clase

table(Titanic.embarked$Pclass,Titanic.embarked$Embarked)

```
De esto puedo deducir que es más probable que las pasajeras embarcaran o bien en South Hampton o bien en Cherburgo. Considerando además de la clase las tarifas de los tickets puedo plantear dos graficos, un boxplot y un histograma

```{r chunk 10}

#creo un dataframe accesorio que no incluya a los pasajeros con variabales missing
Titanic.embarked<-filter(Titanic.embarked[Titanic.embarked$Pclass==1 & Titanic.embarked$Embarked!="Q" & Titanic.embarked$Fare<300,])
Titanic.embarked<-Titanic.embarked %>% 
  filter_all(~ !is.na(.))

#boxplot
ggplot(Titanic.embarked,aes(x=Embarked, y=Fare))+geom_boxplot()+ scale_y_continuous(breaks = seq(0,300,20))

#quiero comparar los pasajeros que embarcaron por C y por S, creo dos subsets para hacer una representación gráfica con histograma. 

Titanic.embarkedC<-Titanic.embarked[Titanic.embarked$Embarked=="C",]
Titanic.embarkedS<-Titanic.embarked[Titanic.embarked$Embarked=="S",]

hist(Titanic.embarkedC$Fare, breaks=30,xlim=c(0,180), col=rgb(1,0,0,0.5), xlab="fare", main="distribution of payment of passanger embarked on c and s")
hist(Titanic.embarkedS$Fare, breaks=30,xlim=c(0,180), col=rgb(0,0,1,0.5), add=T)
legend("topleft", legend=c("embarked on C","embarked on S"), col=c(rgb(1,0,0,0.5), 
     rgb(0,0,1,0.5)), pt.cex=2, pch=15 )


```

En ambos llego a la misma conclusión. Que lo más probable es que las pasajeras embarcaran en el puerto S, ya que apróximadament el 70% de los pasajeros de primera clase que pagaron por sus tickets 80 libras o menos embarcaron por la puerta S mientras que en el caso de la puerta C solo lo hicieron un 50%.En el histograma veo información similar, hay más probabilidad de que los pasajeros embarcaran por la puerta S que por la C. 

En este caso voy a optar por considerar que las pasajeras embarcaron en el puerto de South Hampton que además es donde más pasajeros embarcaron, aún así todo apunta a que son missing values completely at Random
Para comprobar que el cambio se ha realizado correctamente hago el recuento otra vez con la función "table"

```{r chunk 11}

#Recuento en dataframe original Titanic_complete
Titanic_complete[Titanic_complete$Embarked=="","Embarked"]<-"S"
table(Titanic_complete$Embarked)
```
### missing values en variable Fare, y zero values 


A priori este valor faltante se podría considerar de tipo MAR(Missing at random), es decir a priori se podría explicar esta variable a partir de la classe y tal vez también por el puerto de embarque pero solo con la clase deberíamos poder tener una aproximación al dato.

```{r chunk 12}
#compruebo el registro completo que corresponde al dato perdido

Titanic_complete[is.na(Titanic_complete$Fare),]

#compruebo en que valores de fare se concentran las tarifas para la tercera clase 
Titanic.class<-filter(Titanic_complete[Titanic_complete$Pclass==3,])
ggplot(Titanic.class,aes(x=Fare))+geom_boxplot()

summary(Titanic.class$Fare)
```

No disponemos de mucha información en el registro del pasajero pero si hacemos un grafico de caja para la tarifa veremos que hay varios valores un tanto extraños que se alejan de la mayoría, este tipo de valores suele afectar a la media, por lo que en este caso será mejor reemplazar el valor de la variable por la mediana que suele verse menos afectada por valores extremos, así pues reemplazo el valor.

```{r chunk 13}
#calculo de la mediana y reemplazo del valor missing
median.fare<-median(Titanic_complete$Fare, na.rm = TRUE)
Titanic_complete[is.na(Titanic_complete$Fare),"Fare"]<-median.fare
#comprobación de que ya no hay valores missing para Fare
sum(is.na(Titanic_complete$Fare))

```

### missing values variable Age

La imputación que haga de esta variable tendrá una repercusión mayor en el modelo por lo tanto quiero primero hacer una evaluación de los valores que si tenemos para esta variable y también de los registros que no tienen esta variable missing para ver cual sería la mejor manera de imputar estos valores. 

En este caso interpreto que las variables missing son también del tipo MAR(Missing at random), es decir que alguna otra variable tal vez pueda explicar la ausencia de estos valores

Por otra parte, una posible causa que se me ocurre es que tal vez los pasajeros de los que no tenemos datos sobre la edad no sobrevivieran al accidente.

Hago un gráfico para comprobarlo.
```{r chunk 14}

#identificadores de los registros con missing data para la variable Age
id.mis.age <- which( is.na(Titanic_complete$Age))
plot(Titanic_complete[id.mis.age,"Survived"])



```

Del gráfico puedo ver que en efecto la mayoría de los datos perdidos sobre la edad se corresponden a pasajeros que no sobrevivieron al  accidente. Por lo tanto en efecto si se trata de valores MAR. 

Hago un histograma y reviso otra vez el resumen de los datos 

```{r chunk 15}

#Distribución de las edades y resumen de los datos. 

hist(Titanic_complete$Age)
summary(Titanic_complete$Age)

```


La distribución de las edades en un histograma se aproximan a una normal (esto se verá en detalle en puntos posteriores)y con el resumen  de datos obtengo que la mediana y la media son bastante similares la media es de 29,88 y la mediana es de 28,00. Normalmente si hay muchos valores extremos o outliers reemplazaría los datos por la mediana pero realmente no tenemos muchos valores extremos y todos entran dentro de lo que podemos considerar valores normales para la edad siendo la persona mayor de unos 80 años y las menores bebes de meses. 

En este caso podría imputar los valores directamente con la media, pero los valores missing son de hasta el 20% por lo que realmente son muchos valores como para imputarlos todos con el mismo valor, una alternativa es generar valores random que se encuentren dentro del rango interquartilico, que realmente constituye el 50% de los registros. 

```{r chunk 16}

#Calculo de valores random que se encuentren entr Q1 Y Q3. 

Q1<-quantile(Titanic_complete$Age,na.rm = TRUE)[[2]]
Q3<-quantile(Titanic_complete$Age,na.rm = TRUE)[[4]]
n.row<-nrow(Titanic_complete[id.mis.age,])
valores<- sample(Q1:Q3,n.row,replace = TRUE)

#reemplazo los valores missing por el conjunto de valores random generados
Titanic_complete[id.mis.age,"Age"]<-valores

#compruebo que los  valores se han substituido correctamentamente contando los valores NA, para la variable Age
sum(is.na(Titanic_complete$Age))

summary(Titanic_complete$Age)

```

Hacer esta imputación provoca que el rango intercuartílico se mantenga más similar al inicial y también que la media se altere menos. Aunque no es un método e imputación ideal. 


### missing values variable cabin

En el caso  de los valores missing para la variable Cabin representan hasta el 77% de los valores que tenemos para esta variable, por lo tanto más de la mitad de la muestra, a priori no creo que estos valores puedan ser imputables no obstante creo que si separamos la letra de los números que forman cada cabina podemos tener categorías más  claras, y ver si hay algún tratamiento que podemos hacer


```{r chunk 17}

#Creo una nueva columna resumen de las cabinas solo con la letra, buscando información sobre las cabinas la letra indica la cubierta en la que se encontraban, y nos puede servir para agrupar las cabinas. 

Titanic_complete$CabinG <- substring(Titanic_complete$Cabin, 1, 1)
#compruebo que la nueva variable se ha creado correctamente con la función head
head(Titanic_complete)
#con las funciones table y addmargins compruebo la cantidad de registros que tengo para cada variable.

addmargins(addmargins(table(Titanic_complete$Pclass,Titanic_complete$CabinG),2),1)

```

De aquí lo más relevante es la suma de valores faltante 77%(1014) respecto al total de valores que podemos ver en la última columna (sum) con el valor de 1309,  Además no vemos una relación clara entre la clase y la cabina, podemos decir que.
*primera clase: A    B    C    D    E  con mayoría en la cabina C>B>D  
*segunda clase: D    E    F (no contamos con suficientes registros para establecer mayorías claras entre los 3 grupos)
*Tercera clase: E    F    G (no contamos con suficientes registros para establecer mayorías claras entre los 3 grupos)

Aún a pesar tener  las cabinas que se asignan más o menos a cada clase considero que en este caso por el volumen tan alto de valores missing es mejor no imputarlos. 

Pero si podemos hacer una última comprobación que me resulta interesante y es el contrastar si los datos missing se corresponden mayoritariamente con los pasajeros que no han sobrevivido, de ser así es posible que haya una  causa para esto y una opción puede ser asignar una cubierta ficticia a las cabinas desconocidas, y así poder trabajar con los datos restantes.

```{r chunk 18}

#quiero verificar si los datos faltantes corresponden mayoritariamente a los pasajeros que no sobrevivieron al accidente por lo que creo una gráfica 

plot(Titanic_complete[Titanic_complete$Cabin=="","Survived"])
Titanic_complete$Cabin<-as.character(Titanic_complete$Cabin)
#substituyo los valores missing por una N para poder trabajar con los demás e incluirlos en el modelo.
Titanic_complete[Titanic_complete$Cabin=="","Cabin"]<-"N"
Titanic_complete[Titanic_complete$CabinG=="","CabinG"]<-"N"

```

Como se esperaba la mayoria de datos faltantes corresponden a pasajeros que no han sobrevivido. 
Compruebo que los cambios se han hecho correctamente.

```{r chunk 19}

sum(is.na(Titanic_complete["Cabin"]))
sum(is.na(Titanic_complete["CabinG"]))

Titanic_complete$Cabin<-as.factor(Titanic_complete$Cabin)
Titanic_complete$CabinG<-as.factor(Titanic_complete$CabinG)

head(Titanic_complete)
```

### Gestion de zeros para la variable Fare

Como hemos visto en el analisis preeliminar hay 15 valores zero para la tarifa. 
Las tarifas deberían estar relacionadas con los tickets, así que compruebo si buscando los mismos números de tickets tenemos el mismo número de registros que cuando buscamos los registros que tienen una tarifa de 0 ya que si un ticket tiene un número igual pero con un valor diferente para la tarifa, tendremos más registros, y es posible que el valor faltante sea igual,


```{r chunk 20}

#comparación del número de registros de variable fare=0 y número de registres correspondientes a los tickets 
Titanic_complete[Titanic_complete$Fare==0,]

nrow(Titanic_complete[Titanic_complete$Fare==0,])

a<-unique(Titanic_complete[Titanic_complete$Fare==0,"Ticket"])

sum_final=0
for (i in a){
  filas= nrow(Titanic_complete[Titanic_complete$Ticket==i,])
  sum_final=sum_final+filas
}
sum_final

```
Pero el resultado es que tenemos el mismo número de registros por lo que o bien los valores de las tarifas son correctos para ese número de tickets o tenemos que encontrar los valores de otra manera.  

Después de esto he buscado información sobre la variable Fare. Por lo que he encontrado es una variable compuesta con varios factores que influyen en la misma, había tarifas especiales en función de la edad y de si se adquirían en grupo o si se compraban en algún "pack" que incluyese acceso al barco y a algún tren, además el precio cambiaba en función del país de compra y habían algunos pasajeros trabajadores de los dueños de la compañia que viajaron gratis por lo que he optado por mantener los zeros y no tratarlos ya que seria plausible que este número reducido de valores fuera correcto aunque no habitual, después de todo es solo el 1% de todos los registros.

## 3.2 Identificación y  tratamiento de valores extremos(Outliers o valors atípicos).

Para comprobar los valores extremos haré visualizaciones de las variables numéricas, Age, SibSp, Parch y Fare.

Para la variable Age, los datos perdidos han sido tratados y fuera de eso en la revisión inicial  que he realizado no he detectado valores atípicos, ya que todos los datos encontrados corresponden a valores normales que podríamos esperar para edades. 

De todos modos hago un gráfico de densidades para comprobar que no hay valores sentinelas u outliers que pudieran salirse de lo esperado y que hubieran pasado desapercibidos. Además me ha resultado interesante plantear un gráfico boxplot para ver si hay también valores sentinelas u outliers considerando una separación por sexos. 

El  resultado de los gráfico es el siguiente: 

```{r chunk 21}
Titanic_complete %>%
  ggplot( aes(x=Sex,y=Age, fill=Sex)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE, alpha=0.6) +
    geom_jitter(color="black", size=0.4, alpha=0.9)+
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    ggtitle("Age Boxplot") +
    xlab("")

ggplot(mapping = aes(x=Titanic_complete$Age))+geom_density()

```
Del gráfico de densidades deduzco que no hay valores sentinelas u outliers. En cuanto a los boxplots planteados realmente no nos dan demasiada información solo que los hombres tienen una mediana de edad más elevada porque hay hombes mayores que afectan a la distribución (de hasta 80 años), cosa que no ocurre con las mujeres. 

Las siguientes variables que quiero estudiar son SibSp, Parch. He hecho representaciones en una tabla donde he contado el número de registros que tienen cada valor de SibSp o Parch. 

Los valores entran dentro de lo que ya esperaba tras haber hecho ya anteriormente uso de la función summary y revisando el contexto de la época, no es descabellado pensar que hubieran personas con 8 o incluso 9 hijos. En el siglo XX hubieron grandes avances médicos por los que la supervivencia de los recién nacidos era más elevada y el uso de anticonceptivos aún no estaba demasiado extendido. Voy a considerar por tanto validos todos los valores y que no hay valores extremos.

```{r chunk 22}

table(Titanic_complete$SibSp)

layout(matrix(c(1,3,2,3), 2, 2, byrow = TRUE))
hist(Titanic_complete$SibSp ,col="blue",main=" Histograma SibSp ",breaks =10)
plot(density(Titanic_complete$SibSp),main="Densidad Sibsp")
boxplot(Titanic_complete$SibSp ,main="Boxplot Sibsp")



table(Titanic_complete$Parch)

layout(matrix(c(1,3,2,3), 2, 2, byrow = TRUE))
hist(Titanic_complete$Parch ,col="blue",main=" Histograma Parch ",breaks =10)
plot(density(Titanic_complete$Parch),main="Densidad Parch")
boxplot(Titanic_complete$Parch ,main="Boxplot Parch")
```

Los gráficos muestran distribuciones similares y concuerdan con lo que he podido comprobar con la función Table. 

Finalmente la última variable en la que tenemos que evaluar los outliers es en Fare, igual que en los casos anteriores planteo un boxplot, un histograma y un grafico de densidad

```{r chunk 23}

#layout(matrix(c(1,1,1,1), 2, 2, byrow = TRUE))
hist(Titanic_complete$Fare ,col="blue",main=" Histograma Fare ",breaks =30)
plot(density(Titanic_complete$Fare),main="Densidad Fare")
boxplot(Titanic_complete$Fare ,main="Boxplot Fare")


```

De el resultado veo que hay valores que en efecto parecen atípicos, concretamente los de precios superiores a las 500 libras. Voy a comprobar los registros para verificar que la tarifa corresponde a un ticket de primera clase ya que, si no fuera así podemos asumir que en efecto se trata de un valor atípico.

```{r chunk 24}

Titanic_complete[Titanic_complete$Fare>400,]
```

Vemos que hay cuatro registros con la misma tarifa superior a 500 libras y todos corresponden al mismo número de ticket y todos a primera clase, así que sería muy posible que este número de ticket tenga esa tarifa y que el valor no sea atípico o Outlier. 
Para comprobarlo aplico el filtro por número de ticket y cuando hago esto compruebo que el ticket PC 17755 tiene siempre el mismo precio 512.3292.

```{r chunk 25}


Titanic_complete[Titanic_complete$Ticket=="PC 17755",]
```


## Otras comprobaciones en la limpieza de datos. 

Fuera deñ tratamiento de valores perdidos, de los outliers y del cambio de formato haré algunas comprobaciones más para tener datos con los que sea más fácil trabajar y que aporten más valor al modelo.

*Per la variable PassengerId
comprobare que no hayan registros repetidos con el mismo passengerId

```{r chunk 26}

length(unique(Titanic_complete$PassengerId))

```
La conclusión que obtengo de esto es que ningun PassengerId esta repetido. Si alguno estuviera repetido el número de registros únicos sería menor.

*Para la variable Fare

Otro cambio que considero necesario es discretizar esta variable, esto se puede hacer con la función round por ejemplo o cut. de momento solo usaré la función round

```{r chunk 27}
#discretización con función round, he preferido  realizarla en una nueva columna (nueva variable que añadiré al dataframe)

fare_d<-round(Titanic_complete$Fare,0)

#hasta pasar a la fase de planteamiento y analisis del proyecto mantendré ambas variables.
Titanic_complete$Fare.d<-fare_d

# compruebo que se ha creado correctamente la variable
head(Titanic_complete)
```

*Para la variable Name

Esta variable tal y como esta expresada no aporta demasiado valor ni podemos extraer datos relevantes de la misma, pero considerando los apellidos tal vez podrían servirnos para establecer relaciones familiares, y nos dan información sobre los títulos (Miss, Mr, Master, etc)


```{r chunk 28}
#divido la variable name en dos nuevas columnas una para el apellido y la otra para el título

vars <- c("Surname","Name2")
Titanic_complete<- separate(Titanic_complete, Name, into = vars, sep = c(","), remove=FALSE,extra = "drop")%>%
  separate(Name2, into = c("Title","namerest"), sep = c(". "),extra="warn")

#elimino la columna residual del nombre que se ha generado al crear dos columnas más una para el apellido y otra para el título
Titanic_complete$namerest<-NULL
# compruebo el dataframe actualizado con los cambios
head(Titanic_complete)

Titanic_complete$Title<- str_trim(Titanic_complete$Title)
Titanic_complete$Surname<- as.factor(str_trim(Titanic_complete$Surname))

#revisión de registro con titulo no reconocible 
Titanic_complete[Titanic_complete$Title=="th",]


```

El valor no reconocible corresponde a "the countes" al tener un espacio entre "the", "countess" no se ha separado correctamente, como solo es un registro no considero necesario revisar el código ya que con la función table me ha permitido revisar que era el único título atípico, pero intentaré optimizarlo, en la revisión final.

Después de esto agrupamos los Titulos de acuerdo a los siguientes grupos "elite_other" (que incluye trabajos de altas categorias sociales como reverendos o doctores o titulos heredados que sin ser nobles otorga una categoría de "elite", como la de maestro), Miss, Mr y Mrs (no he agrupado estos atributos porque nos puede aportar información sobre mujeres casadas o solteras y hombres que no tienen ningún título ni profesiones que se puedan considerar d e"elite"), por último la categoría final sería "Noble" en este grupo se consideran a todos los pasajeros con títulos nobiliarios. 


```{r chunk 29}
#agrupación de categorías.

Titanic_complete$Title[Titanic_complete$Title %in% c('Capt','Col', 'Dr','Major','Rev','Master')] <-"elite_other"
Titanic_complete$Title[Titanic_complete$Title %in% c('Miss', 'Ms', 'Mlle')]<- 'Miss'
Titanic_complete$Title[Titanic_complete$Title %in% c('Mme')] <-'Mrs' 
Titanic_complete$Title[Titanic_complete$Title %in% c('Don','Jonkheer', 'Sir','Lady','Dona','th')] <-'Noble'

Titanic_complete$Title<-as.factor(Titanic_complete$Title)

table(Titanic_complete$Title)


```

* Para las variables Sibsp y Parch

Para estas variables no haré cambios. Pero si considero interesante generar una nueva que incluya los integrantes totales de la familia de un pasajero. para determinar si hay una relación entre e tamaño de una familia y la supervivencia. 

```{r chunk 30}
#creo la variable Family.unit
Titanic_complete$Family.unit<-Titanic_complete$SibSp+Titanic_complete$Parch+1
#compruebo que la variaable se ha creado correctamente
head(Titanic_complete)
```

Una vez limpiados los datos y creadas las nuevas variables vuelvo a revisar los datos de los que dispongo con las funciones str y summary 

```{r chunk 31}
str(Titanic_complete)
summary(Titanic_complete)
```

El resultado es que tengo muchas más variables pero no todas pasarán a la fase de análisis. 
Además ya no hay missing values (excepto en el apartado "Survived" donde es normal ya que hemos combinado los datos de train y test).

Y todos los datos están en formatos adecuados para su tratamiento (númerico o factor), exceptuando la variable Name, pero es una variable que no pasará a la fase de análisis.


# 4. Analisis de datos.


## 4.1 Selección de los grupos de datos que se quieren analizar/comparar (planificación de los análisis a aplicar).

El objetivo del análisis es predecir la supervivencia de los pasajeros del Titanic en el grupo Test. 

Los análisis se harán en base al  grupo de datos de Entrenamiento, por lo que antes de iniciar las pruebas estadisticas del punto 4.3 hare la separación de datos otra vez en grupos "Train" y "Test"
En cuanto a las variables que utilizaré a partir de ahora serán:

*PassangerID (solo con finalidad de identificación de registro)
*set_type (solo con finalidad de volver a separar datos train/test)
*Pclass
*Title
*Sex
*Age
*SibSp/Parch/Family.unit (la información proporcionada por estas variables puede ser redundante, por lo que es posible que solo utilice Family.unit, pero quiero hacer algunas comprobaciones antes de decidirlo)
*Fare.d
*CabinG
*Embarked.

### Selección de variables.

* Separación de variables en numéricas o categóricas
  * Para las variables numéricas (histogramas, boxplot (ya realizado en apartado "limpieza de datos")), correlación entre variables)
  * Para variables categóricas (gráficos de barras)
* Decisión sobre las variables finales a utilizar en el análisis

### Análisis exploratorio

*Relación entre variables y supervivencia.
  *¿Qué incrementa la supervivencia?¿edad, sexo,clase,tarifa,puerto de embarque?
  *los títulos nobiliarios garantizan una mayor supervivencia?¿las famílias numerosas tenían menos posibilidades de salvar a alguno de sus miembros?¿la ubicación de las cabinas en relación al punto de colapso del barco nos indica cuál es la mejor cubierta para sobrevivir al accidente?
  
* Decisión sobre las variables finales a utilizar en el análisis

*Desarrollo del punto 4.1*

Para seleccionar las variables primero quiero hacer un estudio preeliminar independiente de cada variable, el tratamiento de las variables categóricas será diferente del que de a las variables numéricas por lo que lo primero que haré será separar las variables en 2 grupos. 

```{r chunk 32}
#identificación de las variables factor y variables numericas
id.factor<- c(2,3,5,6,7,14,16)
id.numeric<-c(8,9,10,17,18)

var.factor<-colnames(Titanic_complete)[id.factor]
var.numeric<-colnames(Titanic_complete)[id.numeric]

head(Titanic_complete[var.factor])
head(Titanic_complete[var.numeric])

#pensar implementar gráficos en bucle

```

```{r chunk 33}

#Histogramas para variables numéricas(cuantitativas), esta revisión nos servirá también para evaluar la normalidad de las variables, lo que se verá al detalle en el punto 4.2 

ggplot(Titanic_complete,aes(x=Age)) + geom_histogram( binwidth=1, fill="#69b3a2", color="#e9ecef", alpha=0.9) +ggtitle("Age") +theme(plot.title = element_text(size=15))
ggplot(Titanic_complete,aes(x=SibSp)) + geom_histogram( binwidth=1, fill="#69b3a2", color="#e9ecef", alpha=0.9) +ggtitle("SibSp") +theme(plot.title = element_text(size=15))
ggplot(Titanic_complete,aes(x=Parch)) + geom_histogram( binwidth=1, fill="#69b3a2", color="#e9ecef", alpha=0.9) +ggtitle("Parch") +theme(plot.title = element_text(size=15))
ggplot(Titanic_complete,aes(x=Family.unit)) + geom_histogram( binwidth=1, fill="#69b3a2", color="#e9ecef", alpha=0.9) +ggtitle("Family.unit") +theme(plot.title = element_text(size=15))
ggplot(Titanic_complete,aes(x=Fare)) + geom_histogram( binwidth=30, fill="#69b3a2", color="#e9ecef", alpha=0.9) +ggtitle("Fare") +theme(plot.title = element_text(size=15))
```

De las variables numéricas podemos ver que la única que tiene una distribución similar a la normal es la variable Age. Por los gráficos que obtenemos de las demás variables podemos tal vez considerar normalizarlas, y ver si con eso se aproximan más a una distreibución normal creo que esto es especialmente interesante para la variable Fare, en la que el rango de valores es muy amplio y va de 0 a 500 libras  



```{r chunk 34}
#Barplot per variables categóricas
ggplot(Titanic_complete, aes(x=Survived))+geom_bar(color="blue",fill=rgb(0.1,0.4,0.5,0.7))
ggplot(Titanic_complete, aes(x=Pclass))+geom_bar(color="blue",fill=rgb(0.1,0.4,0.5,0.7))
ggplot(Titanic_complete, aes(x=Surname))+geom_bar(color="blue",fill=rgb(0.1,0.4,0.5,0.7))
ggplot(Titanic_complete, aes(x=Title))+geom_bar(color="blue",fill=rgb(0.1,0.4,0.5,0.7))
ggplot(Titanic_complete, aes(x=Sex))+geom_bar(color="blue",fill=rgb(0.1,0.4,0.5,0.7))
ggplot(Titanic_complete, aes(x=Embarked))+geom_bar(color="blue",fill=rgb(0.1,0.4,0.5,0.7))
ggplot(Titanic_complete,aes(x=CabinG))+geom_bar(color="blue",fill=rgb(0.1,0.4,0.5,0.7))
ggplot(Titanic_complete[Titanic_complete$CabinG!="N",],aes(x=CabinG))+geom_bar(color="blue",fill=rgb(0.1,0.4,0.5,0.7))
#pensar plantear for loop?
```
    
## 4.2 Comprobación de la normalidad i homogeneidad de la variancia.


## 4.3 Aplicación de pruebas estadísticas para comparar los grupos de datos. 
En funció de les dades i de l’objectiu de l’estudi, aplicar proves de contrast d’hipòtesis, correlacions, regressions, etc. Aplicar almenys tres mètodes d’anàlisi diferents









    
```{r chunk 65}

#Separación de dataset Train para analisis

Train.f<-Titanic_complete%>%
  select(PassengerId,Survived,Pclass,Title,Sex,Age,SibSp,Parch,Embarked,Set_type,CabinG,Fare.d,Family.unit)%>%
  filter(Set_type=="train")
str(Train.f)

```

El número de registros y de variables coinciden con lo que esperabamos además la interpretación (variable numérica/factor) es también la que esperabamos.





hist(Titanic_complete[Titanic_complete$Pclass==2,"Fare"], breaks=30, xlim=c(0,20), col=rgb(1,0,0,0.5), xlab="Fare", 
     ylab="frequency", main="Fare payed class1" )
hist(Titanic_complete[Titanic_complete$Pclass==3,"Fare"], breaks=30, xlim=c(0,20), col=rgb(0,0,1,0.5),add=T)
#hist(Titanic_complete[Titanic_complete$Pclass==3,"Fare"], breaks=30, xlim=c(0,300), col=rgb(0,1,0,0.5), add=T)
legend("topright", legend=c("Ixos","Primadur"), col=c(rgb(1,0,0,0.5), 
     rgb(0,0,1,0.5)), pt.cex=2, pch=15 )



El tratamiento de variables numéricas zeros o missing values, será diferente del tratamiento de las variables categóricas missing, por lo que el siguiente paso que haré es separar las variables por numéricas y categóricas y haré representaciones gráficas que me ayuden a tener más información y poder enfocar mejor el estudio.

4.1. Selecció dels grups de dades que es volen analitzar/comparar (planificació dels
anàlisis a aplicar).
4.2. Comprovació de la normalitat i homogeneïtat de la variància.


4.3. Aplicació de proves estadístiques per comparar els grups de dades. En funció de les dades i de l’objectiu de l’estudi, aplicar proves de contrast d’hipòtesis,correlacions, regressions, etc. Aplicar almenys tres mètodes d’anàlisi diferents.
5. Representació dels resultats a partir de taules i gràfiques.


